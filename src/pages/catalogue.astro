---
import ReturnHome from "$components/controls/ReturnHome.astro"
import Layout from "$layouts/Layout.astro"

/**
 * Catalogue page
 */
const pageTitle = "Catalogue"
---

<Layout title={pageTitle}>
	<section>
		<h1>{pageTitle}</h1>
		<p>
			Where I keep track of books, movies, songs, video games, and other media I consume. Keep in
			mind that this is a personal catalogue, incomplete and biased.
		</p>
		<p>
			<ReturnHome />
		</p>
		<section>
			<form class="mb-2.5 grid grid-cols-2 gap-5 text-xs sm:grid-cols-4 sm:text-sm">
				<div class="group col-span-2 flex items-center">
					<i class="fas fa-search group-has-focus:text-primary mr-1.5"></i>
					<input
						id="query"
						type="text"
						placeholder="Search a book, movie, or video game..."
						class="bg-body-light group-has-focus:text-primary dark:bg-body-dark w-full truncate overflow-hidden border-b-[0.1rem] border-dotted whitespace-nowrap outline-hidden placeholder:truncate"
					/>
				</div>
				<select id="rating-filter" class="border-b-[0.1rem] border-dotted">
					<option value="" selected>⭐ all ratings</option>
					<option value="5">😍 loved it</option>
					<option value="4">😀 liked it</option>
					<option value="3">🙂 mid</option>
					<option value="2">🙁 disliked it</option>
					<option value="1">😡 hated it</option>
				</select>
				<select id="emotions-filter" class="border-b-[0.1rem] border-dotted">
					<option value="" selected>🎭 all emotions</option>
				</select>
			</form>

			<div id="reviews-container">
				<p class="text-gray-500">Loading reviews...</p>
			</div>
		</section>
	</section>

	<script>
		import type { Emotion } from "./api/catalogue/emotions"
		import type { Review } from "./api/catalogue/reviews"

		// Store rating emojis for different ratings
		const ratingEmojis: { [key: number]: string } = {
			1: "😡 hated it",
			2: "🙁 disliked it",
			3: "🙂 mid",
			4: "😀 liked it",
			5: "😍 loved it",
		}

		// Store fetched emotions for lookup by ID
		const allEmotionsMap = new Map<string | number, Emotion>()

		// Fetch and display emotions, and populate the map
		async function loadEmotions() {
			const select = document.getElementById("emotions-filter")
			if (!select) return

			// Reset to default option while loading
			select.innerHTML = '<option value="" selected>🎭 all emotions</option>'

			try {
				const response = await fetch("/api/catalogue/emotions")
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
				const emotions = /** @type {Emotion[]} */ (await response.json())
				const sortedEmotions = [...emotions].sort((a, b) => a.name.localeCompare(b.name))

				// Build <option> elements
				sortedEmotions.forEach((emotion: Emotion) => {
					allEmotionsMap.set(emotion.id, emotion)

					const opt = document.createElement("option")
					opt.value = String(emotion.id)
					opt.textContent = `${emotion.emoji} ${emotion.name}`
					select.appendChild(opt)
				})
			} catch (err) {
				console.error("Failed to load emotions:", err)
				const fallback = document.createElement("option")
				fallback.disabled = true
				fallback.textContent = "⚠️ failed to load emotions"
				select.appendChild(fallback)
				throw err
			}
		}

		// Get current filter values from the form
		function getFilterValues() {
			const queryInput = document.getElementById("query") as HTMLInputElement
			const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement
			const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement

			return {
				query: queryInput?.value || "",
				rating: ratingFilter?.value || "",
				emotion: emotionsFilter?.value || "",
			}
		}

		// Fetch and display reviews, using the populated emotions map
		async function loadReviews() {
			const container = document.getElementById("reviews-container")
			if (!container) return

			// Show loading message
			container.innerHTML = '<p class="text-gray-500">Loading reviews...</p>'

			// Get filter values
			const filters = getFilterValues()

			// Build URL with query params
			const params = new URLSearchParams()
			if (filters.query) params.append("query", filters.query)
			if (filters.rating) params.append("rating", filters.rating)
			if (filters.emotion) params.append("emotion", filters.emotion)

			const url = `/api/catalogue/reviews${params.toString() ? "?" + params.toString() : ""}`

			try {
				const response = await fetch(url)
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
				const reviews: Review[] = await response.json()

				container.innerHTML = "" // Clear loading message

				reviews.forEach((review) => {
					const blockDiv = document.createElement("div")
					blockDiv.className = "card"

					// Map emotion IDs from the review to their names using the map
					const reviewEmotionNames = review.emotions
						.map((id: number) => {
							const name = allEmotionsMap.get(id)?.name
							return name ? `<i>${name}</i>` : undefined
						})
						.filter((name): name is string => name !== undefined)
						.join(", ") // Join the names with a comma

					// Use a fallback text if no emotions were found or mapped
					const emotionsText =
						reviewEmotionNames.length > 0 ? reviewEmotionNames : "various emotions"

					blockDiv.innerHTML = `
                        <article>
                            <h3 class="my-0 leading-8">${review.source_id}</h3>
                            <p class="my-0"><span>${ratingEmojis[review.rating]}, and felt ${emotionsText}.</span></p>
                            <p class="my-0">« ${review.comment} » - March 2025</p>
                        </article>
                    `

					container.appendChild(blockDiv)
				})

				if (reviews.length === 0) {
					container.innerHTML = "<p>No reviews found matching your criteria.</p>"
				}
			} catch (error) {
				console.error("Failed to load reviews:", error)
				container.innerHTML = `<p class="text-red-500">Failed to load reviews.</p>`
			}
		}

		// Add event listeners to form controls to trigger filtering
		function setupFilterListeners() {
			const queryInput = document.getElementById("query") as HTMLInputElement
			const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement
			const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement

			// Use input event for text search with small delay
			let debounceTimer: number | undefined
			queryInput?.addEventListener("input", () => {
				clearTimeout(debounceTimer)
				debounceTimer = setTimeout(loadReviews, 100) as unknown as number
			})

			// Use change event for dropdowns
			ratingFilter?.addEventListener("change", loadReviews)
			emotionsFilter?.addEventListener("change", loadReviews)
		}

		document.addEventListener("DOMContentLoaded", async () => {
			try {
				await loadEmotions() // Wait for emotions to load and map to be populated
				await loadReviews() // Now load reviews, which will use the map
				setupFilterListeners() // Set up event listeners for filtering
			} catch (error) {
				console.error("Error initializing catalogue page:", error)
			}
		})
	</script>
</Layout>
