---
import ReturnHome from "$components/controls/ReturnHome.astro"
import Layout from "$layouts/Layout.astro"

/**
 * Catalogue page
 */
const pageTitle = "Catalogue"
---

<Layout title={pageTitle}>
	<section>
		<h1>{pageTitle}</h1>
		<p>
			Where I keep track of books, movies, songs, video games, and other media I consume. Keep in
			mind that this is a personal catalogue, incomplete and biased.
		</p>
		<p>
			<ReturnHome />
		</p>
	</section>
	<section>
		<form class="mb-5 grid grid-cols-2 gap-5 text-xs sm:grid-cols-4 sm:text-sm">
			<div class="group col-span-2 flex items-center">
				<i class="fas fa-search group-has-focus:text-primary mr-1.5"></i>
				<input
					id="query"
					type="text"
					placeholder="Search a book, movie, or video game..."
					class="group-has-focus:text-primary w-full truncate overflow-hidden border-b-[0.1rem] border-dotted whitespace-nowrap outline-hidden placeholder:truncate"
				/>
			</div>
			<select id="rating-filter" class="border-b-[0.1rem] border-dotted">
				<option value="" selected>‚≠ê all ratings</option>
				<option value="5">üòç loved it</option>
				<option value="4">üòÄ liked it</option>
				<option value="3">üòê mid</option>
				<option value="2">üôÅ disliked it</option>
				<option value="1">üò° hated it</option>
			</select>
			<select id="emotions-filter" class="border-b-[0.1rem] border-dotted">
				<option value="" selected>üé≠ all emotions</option>
			</select>
		</form>

		<div id="reviews-container">
			<p class="text-gray-500">Loading reviews...</p>
		</div>
		<button id="load-more" class="button" type="button"> Load more </button>
	</section>

	<script>
		import type { Emotion } from "./api/catalogue/emotions"
		import type { Review } from "./api/catalogue/reviews"
		import { ReviewCard } from "../components/catalogue/ReviewCard"

		/**
		 * Sync filter & pagination state to the URL
		 */
		let currentLimit = 5
		const LIMIT_STEP = 5
		function updateUrl(filters: ReturnType<typeof getFilterValues>) {
			const params = new URLSearchParams()
			if (filters.query) params.set("query", filters.query)
			if (filters.rating) params.set("rating", filters.rating)
			if (filters.emotion) params.set("emotion", filters.emotion)
			if (currentLimit !== LIMIT_STEP) params.set("limit", String(currentLimit))

			history.replaceState(
				null,
				"",
				`${location.pathname}${params.toString() ? "?" + params.toString() : ""}`
			)
		}

		// Fetch and display emotions, and populate the map
		const allEmotionsMap = new Map<string | number, Emotion>()
		async function loadEmotions() {
			const select = document.getElementById("emotions-filter")
			if (!select) return

			// Reset to default option while loading
			select.innerHTML = '<option value="" selected>üé≠ all emotions</option>'

			try {
				const response = await fetch("/api/catalogue/emotions")
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
				const emotions: Emotion[] = await response.json()
				const sortedEmotions = [...emotions].sort((a, b) => a.name.localeCompare(b.name))

				// Build <option> elements
				sortedEmotions.forEach((emotion: Emotion) => {
					allEmotionsMap.set(emotion.id, emotion)

					const opt = document.createElement("option")
					opt.value = String(emotion.id)
					opt.textContent = `${emotion.emoji} ${emotion.name}`
					select.appendChild(opt)
				})
			} catch (err) {
				console.error("Failed to load emotions:", err)
				const fallback = document.createElement("option")
				fallback.disabled = true
				fallback.textContent = "‚ö†Ô∏è failed to load emotions"
				select.appendChild(fallback)
				throw err
			}
		}

		// Get current filter values from the form
		function getFilterValues() {
			const queryInput = document.getElementById("query") as HTMLInputElement
			const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement
			const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement

			return {
				query: queryInput?.value || "",
				rating: ratingFilter?.value || "",
				emotion: emotionsFilter?.value || "",
			}
		}

		// Fetch and display reviews, using the populated emotions map
		async function loadReviews() {
			const container = document.getElementById("reviews-container")
			if (!container) return

			// Show loading message
			container.innerHTML = '<p class="text-gray-500">Loading reviews...</p>'

			// Get filter values
			const filters = getFilterValues()

			// Build URL with query params
			const params = new URLSearchParams()
			if (filters.query) params.append("query", filters.query)
			if (filters.rating) params.append("rating", filters.rating)
			if (filters.emotion) params.append("emotion", filters.emotion)
			if (currentLimit) params.set("limit", String(currentLimit))
			const url = `/api/catalogue/reviews${params.toString() ? "?" + params.toString() : ""}`

			try {
				const response = await fetch(url)
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
				const reviews: Review[] = await response.json()

				container.innerHTML = "" // Clear loading message

				reviews.forEach((review) => {
					const reviewCard = new ReviewCard()
					reviewCard.setReviewData(review, allEmotionsMap)
					container.appendChild(reviewCard)
				})

				if (reviews.length === 0) {
					container.innerHTML = "<p>No reviews found matching your criteria.</p>"
				}

				// Show or hide the load‚Äëmore button
				const loadMoreBtn = document.getElementById("load-more")
				if (loadMoreBtn) {
					if (reviews.length === currentLimit) {
						loadMoreBtn.classList.remove("hidden")
					} else {
						loadMoreBtn.classList.add("hidden")
					}
				}

				updateUrl(filters)
			} catch (error) {
				console.error("Failed to load reviews:", error)
				container.innerHTML = `<p class="text-red-500">Failed to load reviews.</p>`
			}
		}

		// Add event listeners to form controls to trigger filtering
		function setupFilterListeners() {
			const queryInput = document.getElementById("query") as HTMLInputElement
			const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement
			const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement

			// Use input event for text search with small delay
			let debounceTimer: number | undefined
			queryInput?.addEventListener("input", () => {
				clearTimeout(debounceTimer)
				debounceTimer = setTimeout(() => {
					currentLimit = LIMIT_STEP
					loadReviews()
				}, 100) as unknown as number
			})

			// Use change event for dropdowns
			ratingFilter?.addEventListener("change", () => {
				currentLimit = LIMIT_STEP
				loadReviews()
			})

			emotionsFilter?.addEventListener("change", () => {
				currentLimit = LIMIT_STEP
				loadReviews()
			})

			// Load‚Äëmore button
			document.getElementById("load-more")?.addEventListener("click", () => {
				currentLimit += LIMIT_STEP
				loadReviews()
			})
		}

		document.addEventListener("DOMContentLoaded", async () => {
			try {
				await loadEmotions()

				// Restore state from URL (if any)
				const params = new URLSearchParams(location.search)
				const queryInput = document.getElementById("query") as HTMLInputElement
				if (params.has("query")) queryInput.value = params.get("query") ?? ""
				const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement
				if (params.has("rating")) ratingFilter.value = params.get("rating") ?? ""
				const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement
				if (params.has("emotion")) emotionsFilter.value = params.get("emotion") ?? ""
				currentLimit = params.has("limit") ? Number(params.get("limit")) || LIMIT_STEP : LIMIT_STEP

				await loadReviews()
				setupFilterListeners()
			} catch (error) {
				console.error("Error initializing catalogue page:", error)
			}
		})

		/**
		 * Hidden function to update existing reviews with IGDB data
		 * <button id="sync-igdb" class="text-primary hover:text-primary/80 text-xs underline">
		 *	üîÑ Sync IGDB covers
		 * </button>
		 */
		document.getElementById("sync-igdb")?.addEventListener("click", async (e) => {
			e.preventDefault()

			const password = prompt("Catalogue password ?")
			if (!password) return

			try {
				const res = await fetch("/api/catalogue/reviews", {
					method: "PATCH",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ password, task: "syncIGDB" }),
				})

				const json = await res.json()
				if (res.ok && json.ok) {
					alert(`‚úÖ ${json.updated} review(s) updated.`)
					await loadReviews()
				} else {
					alert(`‚ùå ${json.error ?? res.status}`)
				}
			} catch (err) {
				console.error(err)
				alert("‚ùå Network or server error.")
			}
		})
	</script>
</Layout>
