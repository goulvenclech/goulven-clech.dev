---
import ReviewCardSkeleton from "$components/catalogue/ReviewCardSkeleton.astro"
import ReturnHome from "$components/controls/ReturnHome.astro"
import Layout from "$layouts/Layout.astro"

/**
 * Catalogue page
 */
const pageTitle = "Catalogue"
---

<Layout
	title={pageTitle}
	description="Where I keep track of books, movies, songs, video games, and other media I consume."
>
	<section>
		<h1>{pageTitle}</h1>
		<p>
			Where I keep track of books, movies, songs, video games, and other media I consume. Keep in
			mind that this is a personal catalogue, incomplete and biased.
		</p>
		<p>
			<ReturnHome />
		</p>
	</section>
	<section>
		<form class="mb-5 grid grid-cols-2 gap-5 text-xs sm:grid-cols-3 sm:text-sm">
			<div class="group col-span-3 flex items-center">
				<i class="fas fa-search group-has-focus:text-primary mr-1.5"></i>
				<input
					id="query"
					type="text"
					placeholder="Search a book, movie, or video game..."
					class="group-has-focus:text-primary w-full truncate overflow-hidden border-b-[0.1rem] border-dotted whitespace-nowrap outline-hidden placeholder:truncate"
				/>
			</div>

			<select id="source-filter" class="border-b-[0.1rem] border-dotted">
				<option value="" selected>‚≠ê everything</option>
				<option value="IGDB">üéÆ video games</option>
				<option value="TMDB_MOVIE">üé¨ movies</option>
				<option value="TMDB_TV">üì∫ shows</option>
			</select>

			<select id="emotions-filter" class="border-b-[0.1rem] border-dotted">
				<option value="" selected>üé≠ all emotions</option>
			</select>

			<!--
			I'm not sure if I want this filter or not. It's useful, but I don't like the vibe.
			So it's hidden for now, but I can still filter by rating using the URL parameter.
			-->
			<select id="rating-filter" class="hidden border-b-[0.1rem] border-dotted">
				<option value="5">üòç loved it</option>
				<option value="4">üòÄ liked it</option>
				<option value="3">üòê mid</option>
				<option value="2">üôÅ disliked it</option>
				<option value="1">üò° hated it</option>
			</select>
		</form>

		<div id="reviews-container">
			<ReviewCardSkeleton />
		</div>
		<button id="load-more" class="button" type="button"> Load more </button>
		<side-note>
			Images and datas are fetched from <a href="https://igdb.com/"
				><abbr title="The Internet Game Database">IGDB</abbr></a
			> for video games and
			<a href="https://themoviedb.org/"><abbr title="The Movie DataBase">TMDB</abbr></a> for movies and
			shows. Their licenses apply.
		</side-note>
	</section>

	<script>
		import type { Emotion } from "./api/catalogue/emotions"
		import type { Review } from "./api/catalogue/reviews"
		import { ReviewCard } from "../components/catalogue/ReviewCard"
		import { ReviewCardSkeleton } from "../components/catalogue/ReviewCardSkeleton"
		import { ReviewsError } from "../components/catalogue/ReviewsError"
		import { ReviewsEmpty } from "../components/catalogue/ReviewsEmpty"

		/**
		 * Sync filter & pagination state to the URL
		 */
		const PAGE_SIZE = 5
		let currentOffset = 0
		function updateUrl(filters: ReturnType<typeof getFilterValues>) {
			const params = new URLSearchParams()
			if (filters.query) params.set("query", filters.query)
			if (filters.rating) params.set("rating", filters.rating)
			if (filters.source) params.set("source", filters.source)
			if (filters.emotion) params.set("emotion", filters.emotion)

			history.replaceState(
				null,
				"",
				`${location.pathname}${params.toString() ? "?" + params.toString() : ""}`
			)
		}

		// Fetch and display emotions, and populate the map
		const allEmotionsMap = new Map<string | number, Emotion>()
		async function loadEmotions() {
			const select = document.getElementById("emotions-filter")
			if (!select) return

			// Reset to default option while loading
			select.innerHTML = '<option value="" selected>üé≠ all emotions</option>'

			try {
				const response = await fetch("/api/catalogue/emotions")
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
				const emotions: Emotion[] = await response.json()
				const sortedEmotions = [...emotions].sort((a, b) => a.name.localeCompare(b.name))
				console.log("Emotions loaded:", sortedEmotions)
				// Build <option> elements
				sortedEmotions.forEach((emotion: Emotion) => {
					allEmotionsMap.set(emotion.id, emotion)

					const opt = document.createElement("option")
					opt.value = String(emotion.id)
					opt.textContent = `${emotion.emoji} ${emotion.name}`
					select.appendChild(opt)
				})
			} catch (err) {
				console.error("Failed to load emotions:", err)
				const fallback = document.createElement("option")
				fallback.disabled = true
				fallback.textContent = "‚ö†Ô∏è failed to load emotions"
				select.appendChild(fallback)
				throw err
			}
		}

		// Get current filter values from the form
		function getFilterValues() {
			const queryInput = document.getElementById("query") as HTMLInputElement
			const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement | null
			const sourceFilter = document.getElementById("source-filter") as HTMLSelectElement
			const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement

			return {
				query: queryInput?.value || "",
				rating: ratingFilter?.value || "", // Still usable from the URL
				source: sourceFilter?.value || "",
				emotion: emotionsFilter?.value || "",
			}
		}

		// Fetch and display reviews, using the populated emotions map
		async function loadReviews({ append = false } = {}) {
			const container = document.getElementById("reviews-container")
			if (!container) return
			if (!append) {
				container.innerHTML = ""
				container.appendChild(new ReviewCardSkeleton())
			}

			// Get filter values
			const filters = getFilterValues()

			// Build URL with query params
			const params = new URLSearchParams()
			if (filters.query) params.append("query", filters.query)
			if (filters.rating) params.append("rating", filters.rating)
			if (filters.source) params.append("source", filters.source)
			if (filters.emotion) params.append("emotion", filters.emotion)
			params.set("limit", String(PAGE_SIZE))
			params.set("offset", String(currentOffset))
			const url = `/api/catalogue/reviews${params.toString() ? "?" + params.toString() : ""}`

			try {
				const response = await fetch(url)
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
				const { reviews, hasMore } = (await response.json()) as {
					reviews: Review[]
					hasMore: boolean
				}

				if (!append) container.innerHTML = ""

				if (reviews.length === 0 && !append) {
					const noResults = new ReviewsEmpty()
					container.appendChild(noResults)
				} else {
					reviews.forEach((review) => {
						const reviewCard = new ReviewCard()
						reviewCard.setReviewData(review, allEmotionsMap)
						container.appendChild(reviewCard)
					})
				}

				// Show or hide the load‚Äëmore button
				const loadMoreBtn = document.getElementById("load-more")
				loadMoreBtn?.classList.toggle("hidden", !hasMore)

				updateUrl(filters)
			} catch (error) {
				console.error("Failed to load reviews:", error)
				container.innerHTML = ""
				const errorMessage = new ReviewsError()
				container.appendChild(errorMessage)
			}
		}

		// Add event listeners to form controls to trigger filtering
		function setupFilterListeners() {
			const queryInput = document.getElementById("query") as HTMLInputElement
			const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement | null
			const sourceFilter = document.getElementById("source-filter") as HTMLSelectElement
			const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement

			// Use input event for text search with small delay
			let debounceTimer: number | undefined
			queryInput?.addEventListener("input", () => {
				clearTimeout(debounceTimer)
				debounceTimer = setTimeout(() => {
					currentOffset = 0
					loadReviews()
				}, 100) as unknown as number
			})

			// Use change event for dropdowns
			ratingFilter?.addEventListener("change", () => {
				currentOffset = 0
				loadReviews()
			})

			sourceFilter?.addEventListener("change", () => {
				currentOffset = 0
				loadReviews()
			})

			emotionsFilter?.addEventListener("change", () => {
				currentOffset = 0
				loadReviews()
			})

			// Load‚Äëmore button
			document.getElementById("load-more")?.addEventListener("click", () => {
				currentOffset += PAGE_SIZE
				loadReviews({ append: true })
			})
		}

		document.addEventListener("DOMContentLoaded", async () => {
			try {
				await loadEmotions()

				// Restore state from URL (if any)
				const params = new URLSearchParams(location.search)
				const queryInput = document.getElementById("query") as HTMLInputElement
				const ratingFilter = document.getElementById("rating-filter") as HTMLSelectElement | null
				const sourceFilter = document.getElementById("source-filter") as HTMLSelectElement
				const emotionsFilter = document.getElementById("emotions-filter") as HTMLSelectElement
				if (params.has("query")) queryInput.value = params.get("query") ?? ""
				if (params.has("rating") && ratingFilter) ratingFilter.value = params.get("rating") ?? ""
				if (params.has("source")) sourceFilter.value = params.get("source") ?? ""
				if (params.has("emotion")) emotionsFilter.value = params.get("emotion") ?? ""
				currentOffset = 0
				await loadReviews()
				setupFilterListeners()
			} catch (error) {
				console.error("Error initializing catalogue page:", error)
			}
		})

		/**
		 * Hidden function to update existing reviews with IGDB data
		 * <button id="sync-igdb" class="text-primary hover:text-primary/80 text-xs underline">
		 *	üîÑ Sync IGDB covers
		 * </button>
		 */
		document.getElementById("sync-igdb")?.addEventListener("click", async (e) => {
			e.preventDefault()

			const password = prompt("Catalogue password ?")
			if (!password) return

			try {
				const res = await fetch("/api/catalogue/reviews", {
					method: "PATCH",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({ password, task: "syncIGDB" }),
				})

				const json = await res.json()
				if (res.ok && json.ok) {
					alert(`‚úÖ ${json.updated} review(s) updated.`)
					await loadReviews()
				} else {
					alert(`‚ùå ${json.error ?? res.status}`)
				}
			} catch (err) {
				console.error(err)
				alert("‚ùå Network or server error.")
			}
		})
	</script>
</Layout>
