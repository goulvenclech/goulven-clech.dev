---
import { getCollection, type CollectionEntry } from "astro:content"
import { getImage } from "astro:assets"
import type { ImageMetadata } from "astro"
import { formatDate, isEntryPublished } from "src/utils"
import { generatePlaceholder } from "src/imageService"
import type { BlogEntry } from "src/utils"
import Block from "./blocks/Block.astro"
export type ClientBlogEntries = BlogEntry[]

/**
 * A component that show all blog entries and where users can search by typing keywords.
 * Or filter by tags and years.
 * Only made with Astro and vanilla JS. Could have done this with React or an already made
 * library ? Maybe...But would I've had as much fun? ğŸ¤·
 */

// Get all published blog entries
const blogEntriesRaw: CollectionEntry<"blog">[] = await getCollection(
	"blog",
	({ data }) => {
		return isEntryPublished(data.published)
	},
)

// Sort blog entries by date
const blogEntries = blogEntriesRaw.sort(
	(a, b) => b.data.date.getTime() - a.data.date.getTime(),
)

const CARD_IMAGE_MAX_WIDTH = 960
const CARD_IMAGE_QUALITY = 80

type EntryImage = ImageMetadata | string | undefined

async function collectCardImageData(
	entryImage: EntryImage,
	id: string,
	variant: "light" | "dark",
): Promise<{ placeholder: string; optimizedSrc?: string }> {
	let placeholder = ""
	let optimizedSrc: string | undefined

	if (!entryImage) {
		return { placeholder, optimizedSrc }
	}

	if (typeof entryImage === "string") {
		optimizedSrc = entryImage
		return { placeholder, optimizedSrc }
	}

	if (entryImage.format === "svg") {
		optimizedSrc = entryImage.src
		return { placeholder, optimizedSrc }
	}

	try {
		// Try to use fsPath from raw image, fallback to checking various properties
		const imageWithPath = entryImage as any
		const fsPath =
			imageWithPath.fsPath ||
			imageWithPath.filepath ||
			imageWithPath.file?.fsPath
		if (fsPath && typeof fsPath === "string") {
			placeholder = await generatePlaceholder(
				fsPath,
				Math.max(entryImage.width, 600),
				entryImage.height,
			)
		}
	} catch (error) {
		console.warn(
			`Failed to generate placeholder for ${variant} image in ${id}:`,
			error,
		)
	}

	optimizedSrc = entryImage.src
	try {
		const targetWidth = Math.min(entryImage.width, CARD_IMAGE_MAX_WIDTH)
		const targetFormat = entryImage.format === "gif" ? "gif" : "webp"
		const optimized = await getImage({
			src: entryImage,
			width: targetWidth,
			format: targetFormat,
			...(targetFormat === "gif" ? {} : { quality: CARD_IMAGE_QUALITY }),
		})
		optimizedSrc = optimized.src
	} catch (error) {
		console.warn(`Failed to optimize ${variant} image in ${id}:`, error)
	}

	return { placeholder, optimizedSrc }
}

const imageAssets = await Promise.all(
	blogEntries.map(async ({ id, data }) => {
		const { placeholder, optimizedSrc } = await collectCardImageData(
			data.image,
			id,
			"light",
		)
		return { id, placeholder, optimizedSrc }
	}),
)

const imageDarkAssets = await Promise.all(
	blogEntries.map(async ({ id, data }) => {
		const { placeholder, optimizedSrc } = await collectCardImageData(
			data.imageDark,
			id,
			"dark",
		)
		return { id, placeholder, optimizedSrc }
	}),
)

const imageAssetMap = new Map(imageAssets.map((asset) => [asset.id, asset]))
const imageDarkAssetMap = new Map(
	imageDarkAssets.map((asset) => [asset.id, asset]),
)

// Extract all tags and years for filter options
const allTags = new Set<string>()
const allYears = new Set<number>()

blogEntries.forEach(({ data }) => {
	data.tags.forEach((tag) => allTags.add(tag))
	allYears.add(data.date.getFullYear())
})

const sortedYears = [...allYears].sort((a, b) => b - a)

// Important tags based on your blog content
const importantTags = [
	{ value: "software engineering", label: "ğŸ’» Software Engineering" },
	{ value: "game development", label: "ğŸ® Game Development" },
	{ value: "coffee", label: "â˜•ï¸ Speciality Coffee" },
]

// Format blog entries for client-side filtering
// Reduce the amount of data sent to the client as much as possible
const blogEntriesFormatted: ClientBlogEntries = blogEntries.map(
	({ id, data }) => {
		const lightAssets = imageAssetMap.get(id)
		const darkAssets = imageDarkAssetMap.get(id)

		return {
			id,
			title: data.title,
			date: formatDate(data.date),
			year: data.date.getFullYear(),
			tags: data.tags,
			abstract: data.abstract,
			image: lightAssets?.optimizedSrc
				? { src: lightAssets.optimizedSrc }
				: undefined,
			imageDark: darkAssets?.optimizedSrc
				? { src: darkAssets.optimizedSrc }
				: undefined,
			imagePlaceholder: lightAssets?.placeholder,
			imageDarkPlaceholder: darkAssets?.placeholder,
			imageAlt: data.imageAlt,
			isPublished: isEntryPublished(data.published, true),
			imageFocusY:
				typeof data.cardImageFocusY === "number"
					? data.cardImageFocusY
					: undefined,
		}
	},
)
---

<form class="mb-5 grid grid-cols-2 gap-5 text-xs sm:text-sm">
	<div class="group col-span-2 flex items-center">
		<i class="fas fa-search group-has-focus:text-primary mr-1.5"></i>
		<input
			id="search-query"
			class="focus:text-primary w-full truncate overflow-hidden border-b-[0.1rem] border-dotted whitespace-nowrap outline-hidden placeholder:truncate"
			placeholder="Search blog entries by title or keywords..."
			type="text"
		/>
	</div>

	<select id="tag-filter" class="border-b-[0.1rem] border-dotted">
		<option value="" selected>ğŸ·ï¸ All topics</option>
		{importantTags.map((tag) => <option value={tag.value}>{tag.label}</option>)}
	</select>

	<select id="year-filter" class="border-b-[0.1rem] border-dotted">
		<option value="" selected>ğŸ—‚ï¸ All years</option>
		{
			sortedYears.map((year) => (
				<option value={year.toString()}>ğŸ“ {year}</option>
			))
		}
	</select>
</form>

<div id="output" class="flex flex-col">
	{
		/* Default SSR output */
		blogEntries.slice(0, 5).map((result) => (
			<Block
				image={result.data.image}
				imageDark={result.data.imageDark}
				to={`/${result.id}`}
				imageFocusY={result.data.cardImageFocusY}
			>
				<h3>{result.data.title}</h3>
				<p class="line-clamp-4 text-ellipsis sm:line-clamp-3">
					<span set:html={result.data.abstract} /> â€”
					<span class="whitespace-nowrap"> {formatDate(result.data.date)}</span>
				</p>
			</Block>
		))
	}
</div>
<button
	id="load-more"
	class={`button mt-0 ${blogEntries.length <= 5 ? "hidden" : ""}`}
	type="button"
>
	Load more
</button>

<div data-blog={JSON.stringify(blogEntriesFormatted)}></div>
<script>
	import { Card } from "./card/Card.ts"
	import { EmptyState } from "./card/EmptyState.ts"
	import type { ClientBlogEntries } from "./Search.astro"
	import {
		filterBlogEntries,
		sortBlogEntries,
		type FilterState,
	} from "./search/searchUtils.ts"

	const PAGE_SIZE = 5
	let currentOffset = 0

	// Okay, here we go ğŸ§™
	// Get blog data and DOM elements
	const blogData = document
		.querySelector("[data-blog]")
		?.getAttribute("data-blog")
	const blogEntries: ClientBlogEntries = blogData ? JSON.parse(blogData) : []

	const queryInput = document.getElementById("search-query") as HTMLInputElement
	const tagFilter = document.getElementById("tag-filter") as HTMLSelectElement
	const yearFilter = document.getElementById("year-filter") as HTMLSelectElement
	const output = document.getElementById("output")

	if (
		!queryInput ||
		!tagFilter ||
		!yearFilter ||
		!output ||
		blogEntries.length === 0
	) {
		throw new Error("Search component is missing required elements.")
	}

	// Sync filter state to URL
	function updateUrl(filters: FilterState) {
		const params = new URLSearchParams()
		if (filters.query) params.set("query", filters.query)
		if (filters.tag) params.set("tag", filters.tag)
		if (filters.year) params.set("year", filters.year)

		history.replaceState(
			null,
			"",
			`${location.pathname}${params.toString() ? "?" + params : ""}`,
		)
	}

	// Get current filter values
	function getFilterState(): FilterState {
		return {
			query: queryInput.value.trim(),
			tag: tagFilter.value,
			year: yearFilter.value,
			sort: "date",
		}
	}

	// Apply filters and update UI
	function applyFilters(append = false) {
		const filters = getFilterState()
		updateUrl(filters)

		let filteredEntries = filterBlogEntries(blogEntries, filters)
		filteredEntries = sortBlogEntries(filteredEntries)

		const totalResults = filteredEntries.length
		const displayedEntries = filteredEntries.slice(0, currentOffset + PAGE_SIZE)
		const hasMoreResults = totalResults > displayedEntries.length

		if (!append) {
			// Clear existing results for new search
			output!.innerHTML = ""
		}

		// Show empty state if no results
		if (filteredEntries.length === 0) {
			const emptyState = new EmptyState().setMessage("No entries found...")
			output!.appendChild(emptyState)
			const loadMoreButton = document.getElementById("load-more")
			if (loadMoreButton) loadMoreButton.classList.add("hidden")
			return
		}

		// Create document fragment for performance
		const fragment = document.createDocumentFragment()

		const entriesToAdd = append
			? filteredEntries.slice(currentOffset, currentOffset + PAGE_SIZE)
			: displayedEntries

		entriesToAdd.forEach((entry) => {
			const searchCard = new Card().fromBlogEntry(entry)
			fragment.appendChild(searchCard)
		})

		output!.appendChild(fragment)

		// Show or hide the load more button
		const loadMoreButton = document.getElementById("load-more")
		if (loadMoreButton) {
			loadMoreButton.classList.toggle("hidden", !hasMoreResults)
		}
	}

	// Initialize filters from URL
	function initializeFromUrl() {
		const params = new URLSearchParams(location.search)
		const query = params.get("query") || ""
		const tag = params.get("tag") || ""
		const year = params.get("year") || ""

		queryInput.value = query
		tagFilter.value = tag
		yearFilter.value = year

		currentOffset = 0
		applyFilters()
	}

	// Add event listeners
	let debounceTimer: number
	queryInput.addEventListener("input", () => {
		clearTimeout(debounceTimer)
		debounceTimer = window.setTimeout(() => {
			currentOffset = 0
			applyFilters()
		}, 300)
	})

	tagFilter.addEventListener("change", () => {
		currentOffset = 0
		applyFilters()
	})

	yearFilter.addEventListener("change", () => {
		currentOffset = 0
		applyFilters()
	})

	// Load more button
	document.getElementById("load-more")?.addEventListener("click", () => {
		currentOffset += PAGE_SIZE
		applyFilters(true)
	})

	// Initialize on page load
	document.addEventListener("DOMContentLoaded", () => {
		currentOffset = 0
		initializeFromUrl()
	})
	// that should do it ğŸ§™
</script>
